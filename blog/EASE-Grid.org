#+TITLE: EASE-Grid: How does it work?
#+DATE: 2016-08-03 Wed
#+EMAIL: cpaulik@gmail.com
#+URI:         /posts/%y/%m/EASE-Grid
#+TAGS:        Python, EASE-Grid, grids, remote-sensing
#+LANGUAGE:    en
#+OPTIONS:     H:3 num:nil toc:nil \n:nil ::t |:t ^:nil -:nil f:t *:t <:t
#+DESCRIPTION: How is the gridding on the EASE grid performed?



#+begin_src python :results output pp :exports both
import pyproj
import math
import pygeogrids
import numpy as np

geod = pygeogrids.geodetic_datum.GeodeticDatum("WGS84")
# circumference of the WGS84 ellipsoid at latitude 30 degrees
circum_lat = geod.ParallelRadi(30) * 2 * math.pi
# wanted resolution in meters
wanted_res = 36000
x_int = int(circum_lat / wanted_res)
actual_res = circum_lat / x_int
print actual_res, x_int

# We want to tile the projection into a grid that has the same sampling as a
# 36x36 km square pixel. So we calculate the size of our pixels in x direction
# and then calculate the necessary size in y direction from that.

# global ease grid 2.0
ease_global = pyproj.Proj(
    "+proj=cea +lat 0=0 +lon 0=0 +lat 1=30 +x 0=0 +y 0=0 +ellps=WGS84 +datum=WGS84 +units=m")

x_min, y_max = ease_global(-180, 90)
x_max, y_min = ease_global(180, -90)

# calculate x extent in meters and size of pixel in x direction
x_extent = x_max - x_min
x_pixel = x_extent / x_int
# the y_pixel size can now be calculated so that the area covered by a pixel is
# a close to the square pixel of the wanted resolution
y_pixel = (actual_res ** 2) / x_pixel

# now we can start from the center of this projection which is at 0,0
# longitude, latitude and also 0,0 x,y and calculate pixel boundaries until we
# reach the border of the projection

# Ease grid pixels are defined with the center points by convention so we
# create shifted points by x_pixel/2 and y_pixel/2

y_arr_neg = np.arange(-y_pixel / 2, y_min, -y_pixel)
x_arr_neg = np.arange(-x_pixel / 2, x_min, -x_pixel)

y_arr_pos = np.arange(y_pixel / 2, y_max, y_pixel)
x_arr_pos = np.arange(x_pixel / 2, x_max, x_pixel)

# now we can put the two arrays together
# one array has to be flipped so they fit together from -180 to +180 in
# longitude and 90 to -90 in latitude.
x_arr = np.concatenate([x_arr_neg[::-1], x_arr_pos])
y_arr = np.concatenate([y_arr_pos[::-1], y_arr_neg])

# let's make a meshgrid and project them to longitude, latitude
x2d, y2d = np.meshgrid(x_arr, y_arr)
lon2d, lat2d = ease_global(x2d, y2d, inverse=True)

# this gives us 2D arrays of shape (408, 964) but data on the 36km EASE grid is
# often distributed as (406, 964) arrays. The reason for that is that the first
# and last row of pixels in latitude direction do not fit completely in the
# projection.

print "Northern border pixel center latitude %3.2f" % ease_global(0, y_arr[0], inverse=True)[1]
print "Northern border pixel latitude %2.0e" % ease_global(0, y_arr[0] + y_pixel / 2, inverse=True)[1]

# This means that these pixels are excluded.
x2d, y2d = np.meshgrid(x_arr, y_arr[1:-1])
lon2d_corr, lat2d_corr = ease_global(x2d, y2d, inverse=True)
print lon2d_corr.shape
#+end_src
